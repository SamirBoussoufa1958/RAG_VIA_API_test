import uvicorn
import logging
import uuid
import os
from datetime import datetime
from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi import Query
from src.llm import generate_response
from src.vector_store import VectorStore
from src.embeddings import get_embedding
from src.indexer import process_document, extract_text_from_file
from src.document_store import DocumentStore
from src.Query_filter  import generate_filters  # ✅ Import the new filtering function

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI()

# Initialize VectorStore and DocumentStore
vector_store = VectorStore()
document_store = DocumentStore()

@app.post("/upload/")
async def upload_file(file: UploadFile = File(...)):
    """Upload a file, extract text, generate embeddings, store in Qdrant, and save full document in MongoDB."""
    vector_store.create_collection()

    try:
        file_bytes = await file.read()
        document_id, _, chunks = process_document(file_bytes, file.filename, file.content_type)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.exception("Error reading or processing file")
        raise HTTPException(status_code=400, detail=f"Error processing file: {e}")

    try:
        # Process each chunk, generate embeddings, and store in Qdrant
        for chunk in chunks:
            embedding = get_embedding(chunk)
            metadata = {
                "document_id": document_id,
                "filename": file.filename,
                "upload_timestamp": datetime.utcnow(),
            }
            vector_store.insert_vector(embedding, document_id, file.filename, metadata)

        # Extract full text from the file
        extracted_text = extract_text_from_file(file_bytes, file.content_type)
        full_document = {
            "document_id": document_id,
            "text": extracted_text,
        }

        # Insert full document into MongoDB
        document_store.insert_document(full_document)

    except Exception as e:
        logger.exception("Error inserting vector or indexing document")
        raise HTTPException(status_code=500, detail=f"Error storing document: {e}")

    return {
        "message": "File processed and indexed successfully",
        "metadata": {"document_id": document_id}
    }



@app.get("/query/")
def query_endpoint(
    query: str,
    top_k: int = 5,
    fetch_full: bool = False,
    doc_ids: list[str] = Query(None)  # ✅ Handles multiple doc_ids correctly
):
    """Retrieve relevant documents from Qdrant and return responses generated by LLM."""
    try:
        query_embedding = get_embedding(query)

        # ✅ Convert doc_ids from Query parameter (if passed)
        if doc_ids:
            filters = generate_filters(doc_ids)
        else:
            filters = None

        search_results = vector_store.search_vector(query_embedding, top_k=top_k, filters=filters)

        if not search_results:
            return {"query": query, "llm_response": "No relevant documents found."}

        retrieved_chunks = []
        for res in search_results:
            doc_id = res["payload"].get("document_id")
            document = document_store.get_document(doc_id, fetch_full=fetch_full)
            if document:
                retrieved_chunks.append(document)
            else:
                logger.warning(f"No document found in MongoDB for ID: {doc_id}")

        if not retrieved_chunks:
            return {"query": query, "llm_response": "No relevant documents found."}

        # ✅ Pass extracted document text to the LLM
        llm_response = generate_response(query, [doc["text"] for doc in retrieved_chunks])

        return {
            "query": query,
            "llm_response": llm_response,
            "retrieved_context": retrieved_chunks
        }

    except Exception as e:
        logger.exception("Error during query execution")
        raise HTTPException(status_code=500, detail=f"Error during query: {e}")


if __name__ == "__main__":
    uvicorn.run("src")



